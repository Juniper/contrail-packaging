#!/usr/bin/env /usr/bin/python
"""
Copyright (c) 2013, Juniper Networks, Inc.
All rights reserved.
Author : Michael Ganley

Build wrapper script.
"""

import argparse
import os
import sys
import shlex
import subprocess
import shutil


manifest_real_path = ""
cacheBaseDir = "/cs-shared/builder/cache"


class ContrailBuild(object):
    """ contrailBuild class to parse and execute the build commands """

    def __init__(self, options):
        global manifest_real_path
        self.opt = options
        if self.opt.manifest_file:
            manifest_real_path = os.path.realpath(self.opt.manifest_file)
            if self.opt.build_num:
                print 'Error: Cannot specify both a build number and manifest file to create sandbox'
                sys.exit(1)
            if self.opt.branch_name:
                print 'Error: Cannot specify both a branch name and manifest file'
                sys.exit(1)

        require_arch = ["centos64_os", "ubuntu-12-04"]
        if not self.opt.arch_type in require_arch:
            print 'Error: Only centos64_os and ubuntu-12-04 are currently supported'
            sys.exit(1)

        required_commands = ["package", "all", "iso"]
        if self.opt.command in required_commands:
            if not self.opt.build_num:
                if not self.opt.sku_name:
                    print "Error: Package/Iso commands need either build number or tag"
                    sys.exit(1)

        """ Make sure we are in sandbox """
        if self.opt.command != 'sandbox':
            if not os.path.exists(".repo"):
                path = str(self.opt.sandbox_name)
                path += '/.repo'
                if not os.path.exists(path):
                    print 'Error cannot find sandbox'
                    sys.exit(1)
                os.chdir (self.opt.sandbox_name)


    def sandbox(self):
        """
        Now finish up with the repo sync command
        """
        if DEBUG:
            print 'sandbox got called'

        """
        Create the sandbox and do the repo init
        """
        print "Creating Sandbox "
        command = 'repo init -u '
        command += str(self.opt.manifest_url)
        command += " -m " + str(self.opt.branch_name) + "/" + str(self.opt.arch_type) +"/manifest-" + str(self.opt.sku_name) +".xml"
        if not os.path.exists(self.opt.sandbox_name):
            os.mkdir (self.opt.sandbox_name)
        os.chdir (self.opt.sandbox_name)
        execute(command,ignore_errors=False)

        """
        Manipulate the manifest.xml file based on the build number if there
        """

        if self.opt.manifest_file:
            print "Using supplied manifest file"
            shutil.copyfile (manifest_real_path, ".repo/manifest.xml")

        if self.opt.build_num:
            print "Using supplied build number"
            build_archive = '/volume/junosv-storage01/contrail/'
            if not os.path.isdir(build_archive):
                print "Can't find the build archive:", build_archive
                sys.exit(1)
            build_archive += str(self.opt.branch_name) + '/'
            build_archive += str(self.opt.build_num) + '/'
            build_archive += str(self.opt.arch_type) + '/'
            build_archive += str(self.opt.sku_name) + '/'
            build_archive += "manifest.xml"
            shutil.copyfile (build_archive, ".repo/manifest.xml")

        print "Syncing repositories.... this could take some time"
        print "log is checkout.log"
        f = open("checkout.log", mode='w')
        data = execute("repo sync", ignore_errors=False)
        f.write (str(data))
        f.close()
        if not self.opt.no_print:
            print data




    def build(self):
        if DEBUG:
            print 'build got called'

        print "Fetching third party libraries"
        print "Log is fetch.log"

        f = open("fetch.log", mode='w')

        if os.path.isdir ("third_party"):
            command = self.opt.python + " third_party/fetch_packages.py"
            data = execute (command, ignore_errors=False)
            f.write (str(data))
            if not self.opt.no_print:
                print data

        if os.path.isdir ("distro"):
            command = self.opt.python + " distro/third_party/fetch_packages.py"
            data = execute (command, ignore_errors=False)
            f.write (str(data))
            f.close()
            if not self.opt.no_print:
                print data

        print "Running top level build"
        print "Log is build.log"

        f = open("build.log", mode='w')
        data = execute("scons", ignore_errors=False)
        f.write (str(data))
        f.close()
        if not self.opt.no_print:
            print data


    def package(self):
        if DEBUG:
            print "Package got called"

        current_dir = os.getcwd()

        os.mkdir ("target")
        os.mkdir ("store")

        command = self.opt.python + " /usr/local/bin/create-config -m "
        command += current_dir + "/.repo/manifest.xml -b " + str(self.opt.build_num) + " config"

        f = open("package.log", mode='w')
        print "log is package.log"
        print "Packaging Contrail.... this could take awhile"
        os.chdir ('tools/packaging/build')
        data = execute(command, ignore_errors=False)
        f.write(str(data))
        if not self.opt.no_print:
            print data

        command = self.opt.python + " ./packager.py --cache-base-dir "
        command += cacheBaseDir
        data = execute(command, ignore_errors=False)
        f.write(str(data))
        f.close()
        if not self.opt.no_print:
            print data


def execute(command, ignore_errors=False):
    """ Function to execute shell command and return the output """

    if DEBUG:
        print 'DEBUG: %s' % command
    pipe = subprocess.Popen(shlex.split(command),
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT,
                            close_fds=True)

    data = pipe.stdout.read()
    rc = pipe.wait()
    cwd = os.getcwd()
    if rc and not ignore_errors:
        print 'Error : Working directory : %s' % cwd
        print 'Error : Failed to execute command: %s\n%s' % (command, data)
        sys.exit(1)
    return data.strip()

def cmd_exists(cmd):
    return subprocess.call("type " + cmd, shell=True, 
        stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0


def parse_options(args):
    """ Parse command line arguments """
    parser = argparse.ArgumentParser(description='Contrail build wrapper script ')

    parser.add_argument('-v', '--verbose', dest='debug', action='store_true',
                        help='Enable verbose mode')

    parser.add_argument('-x', '--xprint', dest='no_print', action='store_true',
                        help="Don\'t print output on STDOUT")

    parser.add_argument('-m', '--manifest', nargs='?', dest='manifest_file',
                        help='Manifest Filename,')

    parser.add_argument('-s', '--sandbox', nargs='?', dest='sandbox_name',
                        default='sandbox',
                        help='New directory name for the sandbox, default : %(default)s')

    parser.add_argument('-p', '--python', nargs='?', dest='python',
                        default='python',
                        help='Path to alternate version of python to use, default : %(default)s')

    parser.add_argument('-u', '--url', dest='manifest_url',
                        default='git@github.com:Juniper/contrail-vnc-private',
                        help='Repository URL to download the manifest file, default : %(default)s')

    parser.add_argument('-n', '--number', nargs='?', dest='build_num',
                        help='Build number to get manifest from')

    parser.add_argument('-b', '--branch', nargs='?', dest='branch_name',
                        default='mainline',
                        help='Branch to use to fetch manifest file')

    parser.add_argument('-k', '--sku', nargs='?', dest='sku_name',
                        default='grizzly',
                        help='Tag to use when creating packages')

    parser.add_argument('-a', '--arch', nargs='?', dest='arch_type',
                        default='centos64_os',
                        help='Branch to use to fetch manifest file')

    subparsers = parser.add_subparsers(title='ContrailBuild Commands',
                                       description='Select one command',
                                       dest='command')

    parser_sandbox = subparsers.add_parser('sandbox',
                                           description='Creates sandbox from either manifest file or build number')
    parser_build = subparsers.add_parser('build', description='Do a build in the sandbox created')
    parser_package = subparsers.add_parser('package', description='Package build')
    parser_all = subparsers.add_parser('all', description='Perform all the functions: sandbox, build, package')

    opt = parser.parse_args(args)
    return opt


if __name__ == '__main__':
    options = parse_options(sys.argv[1:])
    DEBUG = options.debug
    build = ContrailBuild(options)

    """ Test to make sure all our commands exist """

	
    if not cmd_exists("git"):
        print "Missing git command"
        sys.exit(1)
 
    if not cmd_exists("repo"):
        print "Missing repo command"
        sys.exit(1)

    if not cmd_exists("scons"):
        print "Missing scons command"
        sys.exit(1)

    if build.opt.command == 'sandbox':
        build.sandbox()
        sys.exit(0)

    if build.opt.command == 'build':
        build.build()
        sys.exit(0)

    if build.opt.command == 'package':
        build.package()
        sys.exit(0)

    if build.opt.command == 'all':
        build.sandbox()
        build.build()
        build.package()
        sys.exit(0)

    print "Unknown command: ", build.opt.command
    sys.exit(1)
